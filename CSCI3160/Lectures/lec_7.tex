\section{Huffman Codes}
Consider an alphabet \(\Sigma\). An \textbf{encoding} is a function that maps each letter in \(\Sigma\) to a binary string, where such a string is called a \textbf{code-word}. 

Given that not all symbols occur with equal frequency, we can assign shorter code-words to more frequent symbols in order to reduce the \textbf{average number of bits per letter}. However, we must enforce a constraint that no letter's code-word is a prefix of another letter's code-word. An encoding satisfying this constraint is called a \textbf{prefix code}. 

For each letter \(\alpha \in \Sigma\), let \(\textit{freq}(\alpha)\) denote the frequency of \(\alpha\), and let \(\textit{len}(\alpha)\) denote the number of bits in the code-word of \(\alpha\). Then, given an encoding, its average length is 
\[
  \sum_{\alpha \in \Sigma} \textit{freq}(\alpha) \cdot \textit{len}(\alpha).
\]

\begin{problem}[The Prefix Code Problem]
  Given an alphabet \(\Sigma\) and the frequency of each letter in it, find a prefix code for \(\Sigma\) with the smallest possible average length. 
\end{problem}

We can utilize a binary tree to represent prefix codes. 

\begin{definition}[Code Tree]
  A \textbf{code tree} on \(\Sigma\) is a binary tree \(T\) such that every leaf node corresponds to a unique letter in \(\Sigma\), and every letter in \(\Sigma\) corresponds to a unique leaf node in \(T\). For every internal node, its left edge is labeled \(0\) and its right edge is labeled \(1\).
\end{definition}

Then we can generate the prefix code for a letter \(\sigma \in \Sigma\) from the tree \(T\) by concatenating the bit labels of the edges on the path from the root to \(\sigma\).

\begin{lemma}
  Every prefix code can be generated by a code tree.
\end{lemma}

Since the codeword length corresponds to the level of the node in \(T\), to solve the problem we can simply find a tree \(T\) that minimizes the average height.

\textbf{Greedy Algorithm}

Let \(n = \vert \Sigma \vert\). Create a set \(S\) of \(n\) stand-alone leaf nodes, each corresponding to a distinct letter in \(\Sigma\). Then repeat the following steps until \(\vert S \vert = 1\):

1. Remove from \(S\) two nodes \(u_1\) and \(u_2\) with the smallest frequencies.

2. Create a new node \(v\) with \(u_1\) and \(u_2\) as its children, and set the frequency of \(v\) to be the sum of the frequencies of \(u_1\) and \(u_2\).

3. Add \(v\) back into \(S\).



We can implement this algorithm in \(\mathcal{O}(n \log n)\) time. 